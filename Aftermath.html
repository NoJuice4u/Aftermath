<html>
	<head>
		<title>
Aftermath
		</title>
		<script type="application/javascript">
function loadJSON(data_uri, zoom)
{
	// data_uri = "http://174.1.52.221:8080/aftermath/map/node/630971503/json";
	// data_uri = "http://www.tutorialspoint.com/json/data.json";
	var xHttpRequest = new XMLHttpRequest();
	var jsonObj;

	const mapCanvas = document.getElementById("mapCanvas");
	const canvasInputBox = document.getElementById("canvasInputBox");
	const canvasInput = document.getElementById("canvasInputBoxInput");
	const tempLineCanvas = document.getElementById("tempLineCanvas");
	const canvasA = mapCanvas.getContext("2d");

	var chosenEdge = -1;
	var inputData = { };
	
	mapCanvas.addEventListener('click', (e) => {
		const mousePos = {
			x: e.clientX - mapCanvas.offsetTop,
			y: e.clientY - mapCanvas.offsetLeft - 50 // -50 is hacky!  Need to factor in screen position as well!!
		};
		var zm = Math.pow(2, zoom);
		
		if(chosenEdge > 0)
		{
			if(canvasInput.value > 0)
			{
				console.log("Set Edge: " + chosenEdge + " : " + canvasInput.value);
				inputData[chosenEdge] = canvasInput.value;
			}
			else
			{
				delete inputData[chosenEdge];
			}
			
			canvasInput.value = "";
		}
		
		var distance = 9999;
		for(edge in jsonObj["mapEdges"])
		{
			var vertexA = jsonObj["mapVertices"][jsonObj["mapEdges"][edge]["vertices"][0]];
			var vertexB = jsonObj["mapVertices"][jsonObj["mapEdges"][edge]["vertices"][1]];
			
			if(vertexA == null || vertexB == null) // Stupid catch-all because my server code sucks
			{
				// console.log("Skipped a Vertex on: " + edge);
				continue;
			}
			
			var coordinatesA = getBearing(ref_lon, ref_lat, vertexA["longitude"], vertexA["latitude"], zm, 600, 300);
			var coordinatesB = getBearing(ref_lon, ref_lat, vertexB["longitude"], vertexB["latitude"], zm, 600, 300);

			var min, max, minX, maxX, minY, maxY, mPos;
			if (coordinatesA['x']<coordinatesB['x'])
			{
				minX = coordinatesA['x'];
				maxX = coordinatesB['x'];
				minY = coordinatesA['y'];
				maxY = coordinatesB['y'];
				mPos = mousePos.x;
			}
			else if (coordinatesA['x']<coordinatesB['x'])
			{
				minX = coordinatesB['x'];
				maxX = coordinatesA['x'];
				minY = coordinatesB['y'];
				maxY = coordinatesA['y'];
				mPos = mousePos.x;
			} else if (coordinatesA['y']<coordinatesB['y'])
			{
				minX = coordinatesA['x'];
				maxX = coordinatesB['x'];
				minY = coordinatesA['y'];
				maxY = coordinatesB['y'];
				mPos = mousePos.y;
			}
			else
			{
				minX = coordinatesB['x'];
				maxX = coordinatesA['x'];
				minY = coordinatesB['y'];
				maxY = coordinatesA['y'];
				mPos = mousePos.y;
			}
			
			if(minX == maxX)
			{
				min = minY;
				max = maxY;
			}
			else
			{
				min = minX;
				max = maxX;
			}
			
			// CrossPoint - the X-Value position on the line (only works for straight lines.)
			var crossPoint = (max - mPos) / (max - min);
			var xRange = Math.abs(maxX - minX);
			var yRange = Math.abs(maxY - minY);
			
			if(crossPoint >= 0 && crossPoint <= 1)
			{
				// Need stricter box testing
				var xPt = (xRange * crossPoint) + minX;
				var yPt = (yRange * crossPoint) + minY;
				
				var xDst = xPt - mousePos.x;
				var yDst = yPt - mousePos.y;
				
				var finalDst = Math.sqrt(Math.pow(xDst, 2) + Math.pow(yDst, 2));
				// range between xPt; mosue
				
				var nearestPoint = { x: xPt, y: yPt};

				if(distance > finalDst)
				{
					chosenEdge = edge;
					distance = finalDst;
				}
				
				var chosenEdgeVertexA = jsonObj["mapVertices"][jsonObj["mapEdges"][chosenEdge]["vertices"][0]];
				var chosenEdgeVertexB = jsonObj["mapVertices"][jsonObj["mapEdges"][chosenEdge]["vertices"][1]];
				
				var coordinatesA = getBearing(ref_lon, ref_lat, chosenEdgeVertexA["longitude"], chosenEdgeVertexA["latitude"], zm, 600, 300);
				var coordinatesB = getBearing(ref_lon, ref_lat, chosenEdgeVertexB["longitude"], chosenEdgeVertexB["latitude"], zm, 600, 300);

				// console.log("Mousey: " + mousePos.x + ", " + mousePos.y + " : " + distance);
				// console.log("ToDraw: " + coordinatesA['x'] + ":" + coordinatesA['y'])
			}
		}
		console.log("Chosen Edge: " + chosenEdge);

		const selectedRoad = document.getElementById("selectedRoadType");
		selectedRoad.innerHTML = "[" + chosenEdge + "] " + jsonObj["mapEdges"][chosenEdge]["mode"] + "<br/>Confidence: " + jsonObj["mapEdges"][chosenEdge]["confidence"];		
		if(typeof inputData[chosenEdge] != 'undefined')
		{
			canvasInput.value = inputData[chosenEdge];
		}
		else
		{
			canvasInput.value = "";
		}
		
		// FOR LOOP HERE
		var length = jsonObj["mapEdges"][chosenEdge]["vertices"].length;
		for(var i = 0; i < length-1; i++)
		{
			var chosenEdgeVertexA = jsonObj["mapVertices"][jsonObj["mapEdges"][chosenEdge]["vertices"][i]];
			var chosenEdgeVertexB = jsonObj["mapVertices"][jsonObj["mapEdges"][chosenEdge]["vertices"][i+1]];
			
			var coordinatesA = getBearing(ref_lon, ref_lat, chosenEdgeVertexA["longitude"], chosenEdgeVertexA["latitude"], zm, 600, 300);
			var coordinatesB = getBearing(ref_lon, ref_lat, chosenEdgeVertexB["longitude"], chosenEdgeVertexB["latitude"], zm, 600, 300);
			
			console.log("FinalDraw: " + i + " :: " + coordinatesA['x'] + ":" + coordinatesA['y'])
			
			var lineWidth = 12;
			var dx = coordinatesB['x'] - coordinatesA['x'];
			var dy = coordinatesB['y'] - coordinatesA['y'];
			var rotation = Math.atan2(dy, dx);
			var lineLength = Math.sqrt(dx * dx + dy * dy);
			
			var xPos = (coordinatesA['x']+coordinatesB['x'])/2;
			var yPos = (coordinatesA['y']+coordinatesB['y'])/2;
			
			canvasInputBox.style.left = xPos;
			canvasInputBox.style.top = yPos;
			
			// canvasInput.style.left = xRange + xPos;
			// canvasInput.style.top = yRange + yPos;
			
			tempLineCanvas.getContext("2d").clearRect(0, 0, tempLineCanvas.width, tempLineCanvas.height);
			
			tempLineCanvasContext = tempLineCanvas.getContext("2d");
			tempLineCanvasContext.beginPath();
			tempLineCanvasContext.globalAlpha = 1;
			tempLineCanvasContext.translate(coordinatesA['x'], coordinatesA['y']);
			tempLineCanvasContext.rotate(rotation);
			tempLineCanvasContext.rect(0, -lineWidth / 2, lineLength, lineWidth);
			tempLineCanvasContext.translate(-coordinatesA['x'], -coordinatesA['y']);
			tempLineCanvasContext.fillStyle = "#FF00FF";
			tempLineCanvasContext.strokeStyle = "#0000FF";
			tempLineCanvasContext.fill();
			tempLineCanvasContext.stroke();
			tempLineCanvasContext.setTransform(1, 0, 0, 1, 0, 0);
			tempLineCanvasContext.closePath();
		}
	});
	
	var drawn = 0;
	var notdrawn = 0; 
	
	xHttpRequest.onreadystatechange = function()
	{
		if (xHttpRequest.readyState == 4  )
		{
			// Javascript function JSON.parse to parse JSON data
			try
			{
				jsonObj = JSON.parse(xHttpRequest.responseText);
			}
			catch(e)
			{
				document.getElementById("mapCanvas").write(e);
			}

			ref_lon = jsonObj["focus"]["longitude"];
			ref_lat = jsonObj["focus"]["latitude"];
			
			document.getElementById("mapCanvas").getContext("2d").clearRect(0, 0, mapCanvas.width, mapCanvas.height);
			
			var zm = Math.pow(2, zoom);
			for(edge in jsonObj["mapEdges"])
			{
				var length = jsonObj["mapEdges"][edge]["vertices"].length;
				for(var i = 0; i < length-1; i++)
				{
					var vertexAId = jsonObj["mapEdges"][edge]["vertices"][i];
					var vertexBId = jsonObj["mapEdges"][edge]["vertices"][i+1];
					
					var edgeObj = jsonObj["mapEdges"][edge];
					
					var vertexA = jsonObj["mapVertices"][vertexAId];
					var vertexB = jsonObj["mapVertices"][vertexBId];
					
					if(vertexA == null || vertexB == null) // Stupid catch-all because my server code sucks
					{
						console.log("Skipped a Vertex on: " + edgeObj);
						continue;
					}
				
					var coordinatesA = getBearing(ref_lon, ref_lat, vertexA["longitude"], vertexA["latitude"], zm, 600, 300);
					var coordinatesB = getBearing(ref_lon, ref_lat, vertexB["longitude"], vertexB["latitude"], zm, 600, 300);
					
					// console.log(coordinatesA['x'] + " -- " + coordinatesA['y'] + " :: " + coordinatesB['x'] + " -- " + coordinatesB['y']);
				
					if((coordinatesA['x'] > mapCanvas.width && coordinatesB['x'] > mapCanvas.width)
					|| (coordinatesA['x'] < 0 && coordinatesB['x'] < 0)
					|| (coordinatesA['y'] > mapCanvas.height && coordinatesB['y'] > mapCanvas.height)
					|| (coordinatesA['y'] < 0 && coordinatesB['y'] < 0))
					{
						notdrawn += 1;
						continue;
						// remove element if not drawn
					}
	
					var dx = coordinatesB['x'] - coordinatesA['x'];
					var dy = coordinatesB['y'] - coordinatesA['y'];
					var rotation = Math.atan2(dy, dx);
					var lineLength = Math.sqrt(dx * dx + dy * dy);

					drawn += 1;
					// canvasA.moveTo(coordinatesA['x'], coordinatesA['y']);
					// canvasA.lineTo(coordinatesB['x'], coordinatesB['y']);
					// canvasA.lineWidth = 5;
					
					canvasA.save();
					canvasA.beginPath();
	
					canvasA.globalAlpha = 1;

					weightScore = Math.round(edgeObj.weight * 25);
					if(weightScore > 255)
					{
						weightScore = 255;
					}

					confidenceScore = Math.round(Math.abs(edgeObj.confidence-1) * 255 * 1.25);
					if(confidenceScore <= 0)
					{
						confidenceScore = 0;
					}
					if(confidenceScore > 255)
					{
						confidenceScore = 255;
					}
					if(weightScore < confidenceScore)
					{
						// differential = (255-confidenceScore) * confidenceScore;
						// weightScore = confidenceScore + differential;
						if(weightScore < confidenceScore) weightScore = confidenceScore;
					}
					weightHex = ("00" + weightScore.toString(16)).substr(-2);
					confidenceHex = ("00" + confidenceScore.toString(16)).substr(-2);
					if(jsonObj["mapEdges"][edge]["marked"] == true)
					{
						hxResultStroke = "FF";
					}
					else
					{
						hxResultStroke = "00";
					}
					colorHex = weightHex + confidenceHex + "00";
					var lineWidth = 8;
					var strokeAlpha = "80";
					if(edgeObj["mode"] == "primary" || edgeObj["mode"] == "secondary" || edgeObj["mode"] == "rail")
					{
						lineWidth = 12;
						strokeAlpha = "FF";
					}

					canvasA.translate(coordinatesA['x'], coordinatesA['y']);
					canvasA.rotate(rotation);
					canvasA.rect(0, -lineWidth / 2, lineLength, lineWidth);
					canvasA.translate(-coordinatesA['x'], -coordinatesA['y']);
					canvasA.fillStyle = "#" + colorHex;
					canvasA.strokeStyle = "#" + hxResultStroke + hxResultStroke + "00" + strokeAlpha;
	
					canvasA.fill();
					canvasA.stroke();
					canvasA.restore();
					canvasA.closePath();
				}
			} 
			
			canvasA.beginPath();
			canvasA.fillText("Drawn: " + drawn, 20, 20);
			canvasA.fillText("Not Drawn: " + notdrawn, 20, 40);
			canvasA.closePath();
		}
	}

	xHttpRequest.open("GET", data_uri, true);
	xHttpRequest.send();
}

function getBearing(rlon, rlat, lon, lat, zoom, xOffset, yOffset)
{
	var coords = new Object();
		coords['x'] = ((((lon - rlon)*zoom)+xOffset)*0.725)+155;
		coords['y'] = (((rlat - lat)*zoom)+yOffset)*0.9;
		
	return coords;
}

function runLoop()
{
	loadJSON("https://www.wc-encephalon.com/aftermath/map/node/2394665718/json?depth=40&zoom=16",16);
}
		</script>
		<script src="https://kryogenix.org/code/browser/sorttable/sorttable.js"></script>
		<style type="text/css">
body {Font-Family:Tahoma; margin: 0px 0px 0px 0px}
table {border-collapse: collapse; padding: 0px}
th {padding: 0px; font-size:10pt; border: 2px ridge #CCCCCC}
td {padding: 0px; font-size:10pt; border: 2px ridge #CCCCCC}
td.absolute {position: absolute}
td.centered {text-align: center}
td.title {font-size: 26pt}
td.canvasContainer {text-align: center; width: 1200px}
table.header {width: 100%; border: 2px ridge; Font-Family:Helvetica; Font-Weight:bold; background-color:#808080; font-size:24pt; color:#FFFFFF; text-align:center}
table.tableContainer {width: 100%}
table.baseMethodContainer {width: 100%}
td.methodIndent {width: 12px; background-color:#FF8080}
td.spacer {background-color:#80FF80}
td.methodCategory {Font-Family:Helvetica; Font-Weight:bold; background-color:#8080FF; font-size:10pt; color:#FFFFFF}
td.function {Font-Weight:bold}
		</style>
	</head>
	<body>
		<table class="header">
			<tr>
				<td class="title">
Aftermath
				</td>
			</tr>
		</table>
		<tr>
			<td>
<div id="googleMap" style="width:1200px;height:600px;position:absolute; z-index:-5"></div><script>function myMap() {var mapProp= { center:new google.maps.LatLng(35.748291015625,139.62203979492188), zoom:16 };var map=new google.maps.Map(document.getElementById("googleMap"),mapProp);}var drawingManager = new google.maps.drawing.DrawingManager();drawingManager.setMap(map);</script><script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBt9HJImP6x4yiqsxpgVIQtDYGXv8WqKWM&callback=myMap&libraries=drawing"></script>			</td>
		</tr>
		<table class="tableContainer" width="100" height="null" style="overflow: visible">
			<tr>
				<td class="canvasContainer">
					<table name="Map" class="GlobalMap" width="1200" height="600" style="overflow: hidden">
						<tr>
							<td width="1200" height="600" colspan="1">
									<div style="overflow:hidden; height:600px">
<canvas id="mapCanvas" width="1200" height="600" style="border:1px solid #d3d3d3; position:relative; top:0; z-index:25">Your browser does not support the HTML5 canvas tag.</canvas>
<canvas id="tempLineCanvas" width="1200" height="600" style="border:1px solid #d3d3d3; position:relative; top:-600; z-index:30; pointer-events:none">Your browser does not support the HTML5 canvas tag.</canvas>
								</div>
<div id="canvasInputBox" style="position:absolute; background-color:#FF6060; top:-500px; left:-500px; z-index:30"><div id="selectedRoadType">&lt;PH&gt;</div><input id="canvasInputBoxInput" name="entry" size="3" style="border-width:2px; border-style:solid; border-color:#FF0000"/></div>							</td>
						</tr>
					</table>
				</td>
			</tr>
		</table>
		<script type="application/javascript">
window.setInterval(runLoop, 5000);
		</script>
	</body>
</html>
